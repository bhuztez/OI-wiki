
<!doctype html>
<html>
<head>
<title>
Sqrt Tree
 -
OI Wiki</title>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="/OI-wiki/static/base.css">

</head>
<body>

<header>
<nav>
<a href="/OI-wiki/"><i class="material-icons">school</i> OI Wiki</a>
</nav>
</header>

<main>

<article>
<h1>Sqrt Tree

<a href="https://github.com/OI-wiki/OI-wiki/blob/master/wiki/e-maxx/sqrt-tree.md"><i class="material-icons">edit</i></a>
<a href="https://github.com/OI-wiki/OI-wiki/commits/master/wiki/e-maxx/sqrt-tree.md"><i class="material-icons">history</i></a></h1>


<aside class="right">




<h4>标签</h4>

<a class="tag" href="/OI-wiki/tagged/e-maxx.html">E-Maxx</a>
<a class="tag" href="/OI-wiki/tagged/data-structure.html">数据结构</a>

</aside>


<aside class="left">
<h2>目录</h2>
<ul>
<li><a href="#_1">描述</a></li>
<li><a href="#_5">更新元素</a></li>
<li><a href="#_11">代码实现</a></li>
<li><a href="#_12">习题</a></li>
</ul>
</aside>


<p>给你一个长度为 n 的序列 <span class="arithmatex">\(\left\langle a_i\right\rangle_{i=1}^n\)</span> ，再给你一个满足结合律的运算 <span class="arithmatex">\(\circ\)</span> （比如 <span class="arithmatex">\(\gcd,\min,\max,+,\operatorname{and},\operatorname{or},\operatorname{xor}\)</span> 均满足结合律），然后对于每一次区间询问 <span class="arithmatex">\([l,r]\)</span> ，我们需要计算 <span class="arithmatex">\(a_l\circ a_{l+1}\circ\dotsb\circ a_{r}\)</span> 。</p>
<p>Sqrt Tree 可以在 <span class="arithmatex">\(O(n\log\log n)\)</span> 的时间内预处理，并在 <span class="arithmatex">\(O(1)\)</span> 的时间内回答询问。</p>
<h2 id="_1">描述</h2>
<h3 id="_2">序列分块</h3>
<p>首先我们把整个序列分成 <span class="arithmatex">\(O(\sqrt{n})\)</span> 个块，每一块的大小为 <span class="arithmatex">\(O(\sqrt{n})\)</span> 。对于每个块，我们计算：</p>
<ol>
<li><span class="arithmatex">\(P_i\)</span> 块内的前缀区间询问</li>
<li><span class="arithmatex">\(S_i\)</span> 块内的后缀区间询问</li>
<li>维护一个额外的数组 <span class="arithmatex">\(\left\langle B_{i,j}\right\rangle\)</span> 表示第 <span class="arithmatex">\(i\)</span> 个块到第 <span class="arithmatex">\(j\)</span> 个块的区间答案。</li>
</ol>
<p>举个例子，假设 <span class="arithmatex">\(\circ\)</span> 代表加法运算 <span class="arithmatex">\(+\)</span> ，序列为 <span class="arithmatex">\(\{1,2,3,4,5,6,7,8,9\}\)</span> 。</p>
<p>首先我们将序列分成三块，变成了 <span class="arithmatex">\(\{1,2,3\},\{4,5,6\},\{7,8,9\}\)</span> 。</p>
<p>那么每一块的前缀区间答案和后缀区间答案分别为</p>
<div class="arithmatex">\[
\begin{split}
&amp;P_1=\{1,3,6\},S_1=\{6,5,3\}\\
&amp;P_2=\{4,9,15\},S_2=\{15,11,6\}\\
&amp;P_3=\{7,15,24\},S_3=\{24,17,9\}\\
\end{split}
\]</div>
<p><span class="arithmatex">\(B\)</span> 数组为：</p>
<div class="arithmatex">\[
B=\begin{bmatrix}
6 &amp; 21 &amp; 45\\
0 &amp; 15 &amp; 39\\
0 &amp; 0 &amp; 24\\
\end{bmatrix}
\]</div>
<p>（对于 <span class="arithmatex">\(i&gt;j\)</span> 的不合法的情况我们假设答案为 0）</p>
<p>显然我们可以在 <span class="arithmatex">\(O(n)\)</span> 的时间内预处理这些值，空间复杂度同样是 <span class="arithmatex">\(O(n)\)</span> 的。处理好之后，我们可以利用它们在 <span class="arithmatex">\(O(1)\)</span> 的时间内回答一些跨块的询问。但对于那些整个区间都在一个块内的询问我们仍不能处理，因此我们还需要处理一些东西。</p>
<h3 id="_3">构建一棵树</h3>
<p>容易想到我们在每个块内递归地构造上述结构以支持块内的查询。对于大小为 <span class="arithmatex">\(1\)</span> 的块我们可以 <span class="arithmatex">\(O(1)\)</span> 地回答询问。这样我们就建出了一棵树，每一个结点代表序列的一个区间。叶子结点的区间长度为 <span class="arithmatex">\(1\)</span> 或 <span class="arithmatex">\(2\)</span> 。一个大小为 <span class="arithmatex">\(k\)</span> 的结点有 <span class="arithmatex">\(O(\sqrt{k})\)</span> 个子节点，于是整棵树的高度是 <span class="arithmatex">\(O(\log\log n)\)</span> 的，每一层的区间总长是 <span class="arithmatex">\(O(n)\)</span> 的，因此我们构建这棵树的复杂度是 <span class="arithmatex">\(O(n\log\log n)\)</span> 的。</p>
<p>现在我们可以在 <span class="arithmatex">\(O(\log\log n)\)</span> 的时间内回答询问。对于询问 <span class="arithmatex">\([l,r]\)</span> ，我们只需要快速找到一个区间长度最小的结点 <span class="arithmatex">\(u\)</span> 使得 <span class="arithmatex">\(u\)</span> 能包含 <span class="arithmatex">\([l,r]\)</span> ，这样 <span class="arithmatex">\([l,r]\)</span> 在 <span class="arithmatex">\(u\)</span> 的分块区间中一定是跨块的，就可以 <span class="arithmatex">\(O(1)\)</span> 地计算答案了。查询一次的总体复杂度是 <span class="arithmatex">\(O(\log\log n)\)</span> ，因为树高是 <span class="arithmatex">\(O(\log\log n)\)</span> 的。不过我们仍可以优化这个过程。</p>
<h3 id="_4">优化询问复杂度</h3>
<p>容易想到二分高度，然后可以 <span class="arithmatex">\(O(1)\)</span> 判断是否合法。这样复杂度就变成了 <span class="arithmatex">\(O(\log\log\log n)\)</span> 。不过我们仍可以进一步加速这一过程。</p>
<p>我们假设</p>
<ol>
<li>每一块的大小都是 <span class="arithmatex">\(2\)</span> 的整数幂次；</li>
<li>每一层上的块大小是相同的。</li>
</ol>
<p>为此我们需要在序列的末位补充一些 <span class="arithmatex">\(0\)</span> 元素，使得它的长度变成 <span class="arithmatex">\(2\)</span> 的整数次幂。尽管有些块可能会变成原来的两倍大小，但这样仍是 <span class="arithmatex">\(O(\sqrt{k})\)</span> 的，于是预处理分块的复杂度仍是 <span class="arithmatex">\(O(n)\)</span> 的。</p>
<p>现在我们可以轻松地确定一个询问区间是否被整个地包含在一个块中。对于区间 <span class="arithmatex">\([l,r]\)</span> （以 0 为起点），我们把端点写为二进制形式。举一个例子，对于 <span class="arithmatex">\(k=4, l=39, r=46\)</span> ，二进制表示为</p>
<div class="arithmatex">\[
l = 39_{10} = 100111_2\\
r = 46_{10} = 101110_2
\]</div>
<p>我们知道每一层的区间长度是相同的，而分块的大小也是相同的（在上述示例中 <span class="arithmatex">\(2^k=2^4=16\)</span> ）。这些块完全覆盖了整个序列，因此第一块代表的元素为 <span class="arithmatex">\([0,15]\)</span> （二进制表示为 <span class="arithmatex">\([000000_2,001111_2]\)</span> ），第二个块代表的元素区间为 <span class="arithmatex">\([16,31]\)</span> （二进制表示为 <span class="arithmatex">\([010000_2,011111_2]\)</span> ），以此类推。我们发现这些在同一个块内的元素的位置在二进制上只有后 <span class="arithmatex">\(k\)</span> 位不同（上述示例中 <span class="arithmatex">\(k=4\)</span> ）。而示例的 <span class="arithmatex">\(l,r\)</span> 也只有后 <span class="arithmatex">\(k\)</span> 位不同，因此他们在同一个块中。</p>
<p>因此我们需要检查区间两个端点是否只有后 <span class="arithmatex">\(k\)</span> 位不同，即 <span class="arithmatex">\(l\oplus r\le 2^k-1\)</span> 。因此我们可以快速找到答案区间所在的层：</p>
<ol>
<li>对于每个 <span class="arithmatex">\(i\in [1,n]\)</span> ，我们找到找到 <span class="arithmatex">\(i\)</span> 最高位上的 <span class="arithmatex">\(1\)</span> ；</li>
<li>现在对于一个询问 <span class="arithmatex">\([l,r]\)</span> ，我们计算 <span class="arithmatex">\(l\oplus r\)</span> 的最高位，这样就可以快速确定答案区间所在的层。</li>
</ol>
<p>这样我们就可以在 <span class="arithmatex">\(O(1)\)</span> 的时间内回答询问啦。</p>
<h2 id="_5">更新元素</h2>
<p>我们可以在 Sqrt Tree 上更新元素，单点修改和区间修改都是支持的。</p>
<h3 id="_6">单点修改</h3>
<p>考虑一次单点赋值操作 <span class="arithmatex">\(a_x=val\)</span> ，我们希望高效更新这个操作的信息。</p>
<h4 id="_7">朴素实现</h4>
<p>首先我们来看看在做了一次单点修改后 Sqrt Tree 会变成什么样子。</p>
<p>考虑一个长度为 <span class="arithmatex">\(l\)</span> 的结点以及对应的序列： <span class="arithmatex">\(\left\langle P_i\right\rangle,\left\langle S_i\right\rangle,\left\langle B_{i,j}\right\rangle\)</span> 。容易发现在 <span class="arithmatex">\(\left\langle P_i\right\rangle\)</span> 和 <span class="arithmatex">\(\left\langle S_i \right\rangle\)</span> 中都只有 <span class="arithmatex">\(O(\sqrt{l})\)</span> 个元素改变。而在 <span class="arithmatex">\(\left\langle B_{i,j}\right\rangle\)</span> 中则有 <span class="arithmatex">\(O(l)\)</span> 个元素被改变。因此有 <span class="arithmatex">\(O(l)\)</span> 个元素在树上被更新。因此在 Sqrt Tree 上单点修改的复杂度是 <span class="arithmatex">\(O(n+\sqrt{n}+\sqrt{\sqrt{n}}+\dotsb)=O(n)\)</span> 。</p>
<h4 id="sqrt-tree-b">使用 Sqrt Tree 替代 B 数组</h4>
<p>注意到单点更新的瓶颈在于更新根结点的 <span class="arithmatex">\(\left\langle B_{i,j}\right\rangle\)</span> 。因此我们尝试用另一个 Sqrt Tree 代替根结点的 <span class="arithmatex">\(\left\langle B_{i,j}\right\rangle\)</span> ，称其为 <span class="arithmatex">\(index\)</span> 。它的作用和原来的二维数组一样，维护整段询问的答案。其他非根结点仍然使用 <span class="arithmatex">\(\left\langle B_{i,j}\right\rangle\)</span> 维护。注意，如果一个 Sqrt Tree 根结点有 <span class="arithmatex">\(index\)</span> 结构，称其 Sqrt Tree 是 <strong>含有索引</strong> 的；如果一个 Sqrt Tree 的根结点有 <span class="arithmatex">\(\left\langle B_{i,j}\right\rangle\)</span> 结构，称其是 <strong>没有索引</strong> 的。而 <span class="arithmatex">\(index\)</span> 这棵树本身是没有索引的。</p>
<p>因此我们可以这样更新 <span class="arithmatex">\(index\)</span> 树：</p>
<ol>
<li>在 <span class="arithmatex">\(O(\sqrt{n})\)</span> 的时间内更新 <span class="arithmatex">\(\left\langle P_i\right\rangle\)</span> 和 <span class="arithmatex">\(\left\langle S_i\right\rangle\)</span> 。</li>
<li>更新 <span class="arithmatex">\(index\)</span> ，它的长度是 <span class="arithmatex">\(O(n)\)</span> 的，但我们只需要更新其中的一个元素（这个元素代表了被改变的块），这一步的时间复杂度是 <span class="arithmatex">\(O(\sqrt{n})\)</span> 的（使用朴素实现的算法）。</li>
<li>进入产生变化的子节点并使用朴素实现的算法在 <span class="arithmatex">\(O(\sqrt{n})\)</span> 的时间内更新信息。</li>
</ol>
<p>注意，查询的复杂度仍是 <span class="arithmatex">\(O(1)\)</span> 的，因为我们最多使用 <span class="arithmatex">\(index\)</span> 树一次。于是单点修改的复杂度就是 <span class="arithmatex">\(O(\sqrt{n})\)</span> 的。</p>
<h3 id="_8">更新一个区间</h3>
<p>Sqrt Tree 也支持区间覆盖操作 <span class="arithmatex">\(\operatorname{Update}(l,r,x)\)</span> ，即把区间 <span class="arithmatex">\([l,r]\)</span> 的数全部变成 <span class="arithmatex">\(x\)</span> 。对此我们有两种实现方式，其中一种会花费 <span class="arithmatex">\(O(\sqrt{n}\log\log n)\)</span> 的复杂度更新信息， <span class="arithmatex">\(O(1)\)</span> 的时间查询；另一种则是 <span class="arithmatex">\(O(\sqrt{n})\)</span> 更新信息，但查询的时间会增加到 <span class="arithmatex">\(O(\log\log n)\)</span> 。</p>
<p>我们可以像线段树一样在 Sqrt Tree 上打懒标记。但是在 Sqrt Tree 上有一点不同。因为下传一个结点的懒标记，复杂度可能达到 <span class="arithmatex">\(O(\sqrt{n})\)</span> ，因此我们不是在询问的时侯下传标记，而是看父节点是否有标记，如果有标记就把它下传。</p>
<h4 id="_9">第一种实现</h4>
<p>在第一种实现中，我们只会给第 <span class="arithmatex">\(1\)</span> 层的结点（结点区间长度为 <span class="arithmatex">\(O(\sqrt{n})\)</span> ）打懒标记，在下传标记的时侯直接更新整个子树，复杂度为 <span class="arithmatex">\(O(\sqrt{n}\log\log n)\)</span> 。操作过程如下：</p>
<ol>
<li>
<p>考虑第 <span class="arithmatex">\(1\)</span> 层上的结点，对于那些被修改区间完全包含的结点，给他们打一个懒标记；</p>
</li>
<li>
<p>有两个块只有部分区间被覆盖，我们直接在 <span class="arithmatex">\(O(\sqrt{n}\log\log n)\)</span> 的时间内 <strong>重建</strong> 这两个块。如果它本身带有之前修改的懒标记，就在重建的时侯顺便下传标记；</p>
</li>
<li>
<p>更新根结点的 <span class="arithmatex">\(\left\langle P_i\right\rangle\)</span> 和 <span class="arithmatex">\(\left\langle S_i\right\rangle\)</span> ，时间复杂度 <span class="arithmatex">\(O(\sqrt{n})\)</span> ；</p>
</li>
<li>
<p>重建 <span class="arithmatex">\(index\)</span> 树，时间复杂度 <span class="arithmatex">\(O(\sqrt{n}\log\log n)\)</span> 。</p>
</li>
</ol>
<p>现在我们可以高效完成区间修改了。那么如何利用懒标记回答询问？操作如下：</p>
<ol>
<li>
<p>如果我们的询问被包含在一个有懒标记的块内，可以利用懒标记计算答案；</p>
</li>
<li>
<p>如果我们的询问包含多个块，那么我们只需要关心最左边和最右边不完整块的答案。中间的块的答案可以在 <span class="arithmatex">\(index\)</span> 树中查询（因为 <span class="arithmatex">\(index\)</span> 树在每次修改完后会重建），复杂度是 <span class="arithmatex">\(O(1)\)</span> 。</p>
</li>
</ol>
<p>因此询问的复杂度仍为 <span class="arithmatex">\(O(1)\)</span> 。</p>
<h4 id="_10">第二种实现</h4>
<p>在这种实现中，每一个结点都可以被打上懒标记。因此在处理一个询问的时侯，我们需要考虑祖先中的懒标记，那么查询的复杂度将变成 <span class="arithmatex">\(O(\log\log n)\)</span> 。不过更新信息的复杂度就会变得更快。操作如下：</p>
<ol>
<li>被修改区间完全包含的块，我们把懒标记添加到这些块上，复杂度 <span class="arithmatex">\(O(\sqrt{n})\)</span> ；</li>
<li>被修改区间部分覆盖的块，更新 <span class="arithmatex">\(\left\langle P_i\right\rangle\)</span> 和 <span class="arithmatex">\(\left\langle S_i\right\rangle\)</span> ，复杂度 <span class="arithmatex">\(O(\sqrt{n})\)</span> （因为只有两个被修改的块）；</li>
<li>更新 <span class="arithmatex">\(index\)</span> 树，复杂度 <span class="arithmatex">\(O(\sqrt{n})\)</span> （使用同样的更新算法）；</li>
<li>对于没有索引的子树更新他们的 <span class="arithmatex">\(\left\langle B_{i,j}\right\rangle\)</span> ；</li>
<li>递归地更新两个没有被完全覆盖的区间。</li>
</ol>
<p>时间复杂度是 <span class="arithmatex">\(O(\sqrt{n}+\sqrt{\sqrt{n}}+\dotsb)=O(\sqrt{n})\)</span> 。</p>
<h2 id="_11">代码实现</h2>
<p>下面的实现在 <span class="arithmatex">\(O(n\log\log n)\)</span> 的时间内建树，在 <span class="arithmatex">\(O(1)\)</span> 的时间内回答询问，在 <span class="arithmatex">\(O(\sqrt{n})\)</span> 的时间内单点修改。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">SqrtTreeItem</span> <span class="nf">op</span><span class="p">(</span><span class="k">const</span> <span class="n">SqrtTreeItem</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">SqrtTreeItem</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">log2Up</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">res</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">res</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">SqrtTree</span> <span class="p">{</span>
 <span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">lg</span><span class="p">,</span> <span class="n">indexSz</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">SqrtTreeItem</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">clz</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">onLayer</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SqrtTreeItem</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">pref</span><span class="p">,</span> <span class="n">suf</span><span class="p">,</span> <span class="n">between</span><span class="p">;</span>

  <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buildBlock</span><span class="p">(</span><span class="kt">int</span> <span class="n">layer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pref</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">pref</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">pref</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">suf</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">suf</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">suf</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buildBetween</span><span class="p">(</span><span class="kt">int</span> <span class="n">layer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lBound</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rBound</span><span class="p">,</span> <span class="kt">int</span> <span class="n">betweenOffs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">bSzLog</span> <span class="o">=</span> <span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bCntLog</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bSz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bSzLog</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bCnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">rBound</span> <span class="o">-</span> <span class="n">lBound</span> <span class="o">+</span> <span class="n">bSz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">bSzLog</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bCnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SqrtTreeItem</span> <span class="n">ans</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bCnt</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">SqrtTreeItem</span> <span class="n">add</span> <span class="o">=</span> <span class="n">suf</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">lBound</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;&lt;</span> <span class="n">bSzLog</span><span class="p">)];</span>
        <span class="n">ans</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">)</span> <span class="o">?</span> <span class="nl">add</span> <span class="p">:</span> <span class="n">op</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">add</span><span class="p">);</span>
        <span class="n">between</span><span class="p">[</span><span class="n">layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">betweenOffs</span> <span class="o">+</span> <span class="n">lBound</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">bCntLog</span><span class="p">)</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ans</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">buildBetweenZero</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">bSzLog</span> <span class="o">=</span> <span class="p">(</span><span class="n">lg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indexSz</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">v</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">suf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">bSzLog</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">build</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">indexSz</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lg</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">updateBetweenZero</span><span class="p">(</span><span class="kt">int</span> <span class="n">bid</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">bSzLog</span> <span class="o">=</span> <span class="p">(</span><span class="n">lg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">v</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="n">suf</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">bid</span> <span class="o">&lt;&lt;</span> <span class="n">bSzLog</span><span class="p">];</span>
    <span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">indexSz</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lg</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">bid</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">build</span><span class="p">(</span><span class="kt">int</span> <span class="n">layer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lBound</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rBound</span><span class="p">,</span> <span class="kt">int</span> <span class="n">betweenOffs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">layer</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">layers</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">bSz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">lBound</span><span class="p">;</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">rBound</span><span class="p">;</span> <span class="n">l</span> <span class="o">+=</span> <span class="n">bSz</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">bSz</span><span class="p">,</span> <span class="n">rBound</span><span class="p">);</span>
      <span class="n">buildBlock</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
      <span class="n">build</span><span class="p">(</span><span class="n">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">betweenOffs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">layer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">buildBetweenZero</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">buildBetween</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">lBound</span><span class="p">,</span> <span class="n">rBound</span><span class="p">,</span> <span class="n">betweenOffs</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">layer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lBound</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rBound</span><span class="p">,</span> <span class="kt">int</span> <span class="n">betweenOffs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">layer</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">layers</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">bSzLog</span> <span class="o">=</span> <span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bSz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bSzLog</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">blockIdx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">lBound</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">bSzLog</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">lBound</span> <span class="o">+</span> <span class="p">(</span><span class="n">blockIdx</span> <span class="o">&lt;&lt;</span> <span class="n">bSzLog</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">bSz</span><span class="p">,</span> <span class="n">rBound</span><span class="p">);</span>
    <span class="n">buildBlock</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">layer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">updateBetweenZero</span><span class="p">(</span><span class="n">blockIdx</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">buildBetween</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">lBound</span><span class="p">,</span> <span class="n">rBound</span><span class="p">,</span> <span class="n">betweenOffs</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">update</span><span class="p">(</span><span class="n">layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">betweenOffs</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kr">inline</span> <span class="n">SqrtTreeItem</span> <span class="nf">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="kt">int</span> <span class="n">betweenOffs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">layer</span> <span class="o">=</span> <span class="n">onLayer</span><span class="p">[</span><span class="n">clz</span><span class="p">[(</span><span class="n">l</span> <span class="o">-</span> <span class="n">base</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">base</span><span class="p">)]];</span>
    <span class="kt">int</span> <span class="n">bSzLog</span> <span class="o">=</span> <span class="p">(</span><span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bCntLog</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lBound</span> <span class="o">=</span> <span class="p">(((</span><span class="n">l</span> <span class="o">-</span> <span class="n">base</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="n">layers</span><span class="p">[</span><span class="n">layer</span><span class="p">])</span> <span class="o">+</span> <span class="n">base</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lBlock</span> <span class="o">=</span> <span class="p">((</span><span class="n">l</span> <span class="o">-</span> <span class="n">lBound</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">bSzLog</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rBlock</span> <span class="o">=</span> <span class="p">((</span><span class="n">r</span> <span class="o">-</span> <span class="n">lBound</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">bSzLog</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">SqrtTreeItem</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">suf</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">l</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lBlock</span> <span class="o">&lt;=</span> <span class="n">rBlock</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SqrtTreeItem</span> <span class="n">add</span> <span class="o">=</span>
          <span class="p">(</span><span class="n">layer</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">query</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">lBlock</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="n">rBlock</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lg</span><span class="p">)</span> <span class="o">-</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                       <span class="o">:</span> <span class="p">(</span><span class="n">between</span><span class="p">[</span><span class="n">layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">betweenOffs</span> <span class="o">+</span> <span class="n">lBound</span> <span class="o">+</span>
                                             <span class="p">(</span><span class="n">lBlock</span> <span class="o">&lt;&lt;</span> <span class="n">bCntLog</span><span class="p">)</span> <span class="o">+</span> <span class="n">rBlock</span><span class="p">]);</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">add</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">pref</span><span class="p">[</span><span class="n">layer</span><span class="p">][</span><span class="n">r</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="k">public</span><span class="o">:</span>
  <span class="kr">inline</span> <span class="n">SqrtTreeItem</span> <span class="n">query</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">query</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>

  <span class="kr">inline</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">SqrtTreeItem</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">v</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
    <span class="n">update</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">SqrtTree</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">SqrtTreeItem</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">n</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">a</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span> <span class="n">lg</span><span class="p">(</span><span class="n">log2Up</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="n">v</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">clz</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lg</span><span class="p">),</span> <span class="n">onLayer</span><span class="p">(</span><span class="n">lg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">clz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">clz</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">clz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">clz</span><span class="p">[</span><span class="n">i</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">tlg</span> <span class="o">=</span> <span class="n">lg</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">tlg</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">onLayer</span><span class="p">[</span><span class="n">tlg</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">layers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
      <span class="n">layers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tlg</span><span class="p">);</span>
      <span class="n">tlg</span> <span class="o">=</span> <span class="p">(</span><span class="n">tlg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">onLayer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">onLayer</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">onLayer</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">betweenLayers</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">layers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">bSzLog</span> <span class="o">=</span> <span class="p">(</span><span class="n">lg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bSz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bSzLog</span><span class="p">;</span>
    <span class="n">indexSz</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">bSz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">bSzLog</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">indexSz</span><span class="p">);</span>
    <span class="n">pref</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">SqrtTreeItem</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">indexSz</span><span class="p">));</span>
    <span class="n">suf</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">layers</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">SqrtTreeItem</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">indexSz</span><span class="p">));</span>
    <span class="n">between</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">betweenLayers</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">SqrtTreeItem</span><span class="o">&gt;</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">lg</span><span class="p">)</span> <span class="o">+</span> <span class="n">bSz</span><span class="p">));</span>
    <span class="n">build</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</td></tr></table>

<h2 id="_12">习题</h2>
<p><a href="https://www.codechef.com/NOV17/problems/SEGPROD">CodeChef - SEGPROD</a> </p>
<p><strong>本页面主要译自 <a href="https://cp-algorithms.com/data_structures/sqrt-tree.html">Sqrt Tree</a> ，版权协议为 CC-BY-SA 4.0。</strong> </p>

</article>


</main>

<div class="footer">
<footer>
<p>&copy; 2016-2019 OI Wiki Team</p>

<p>本页面的全部内容在 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a> 协议之条款下提供，附加条款亦可能应用
</p>





</footer>
</div>

</body>
</html>
