
<!doctype html>
<html>
<head>
<title>
Newton's method for finding roots
 -
OI Wiki</title>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="/OI-wiki/static/base.css">

</head>
<body>

<header>
<nav>
<a href="/OI-wiki/"><i class="material-icons">school</i> OI Wiki</a>
</nav>
</header>

<main>

<article>
<h1>Newton's method for finding roots

<a href="https://github.com/OI-wiki/OI-wiki/blob/master/wiki/e-maxx/roots_newton.md"><i class="material-icons">edit</i></a>
<a href="https://github.com/OI-wiki/OI-wiki/commits/master/wiki/e-maxx/roots_newton.md"><i class="material-icons">history</i></a></h1>


<aside class="right">




<h4>标签</h4>

<a class="tag" href="/OI-wiki/tagged/e-maxx.html">E-Maxx</a>

</aside>


<aside class="left">
<h2>目录</h2>
<ul>
<li><a href="#_1">算法描述</a></li>
<li><a href="#_2">求解平方根</a></li>
<li><a href="#_3">求解整数平方根</a></li>
<li><a href="#_4">高精度平方根</a></li>
<li><a href="#_5">习题</a></li>
</ul>
</aside>


<p>本文介绍牛顿迭代法（Newton's method for finding roots）求解方程的近似解。牛顿在 1664 年发明了这个方法。具体的任务是，对于在 <span class="arithmatex">\([a,b]\)</span> 上连续且单调的函数 <span class="arithmatex">\(f(x)\)</span> ，求 <span class="arithmatex">\(f(x)=0\)</span> 的近似解。</p>
<h2 id="_1">算法描述</h2>
<p>初始时我们从给定的 <span class="arithmatex">\(f(x)\)</span> 和一个粗略的近似解 <span class="arithmatex">\(x_0\)</span> 开始。</p>
<p>假设我们目前的近似解是 <span class="arithmatex">\(x_i\)</span> ，那么为了得到更优的近似解，我们画出与 <span class="arithmatex">\(f(x)\)</span> 切于点 <span class="arithmatex">\((x_0,f(x_0))\)</span> 的直线 <span class="arithmatex">\(l\)</span> ，将 <span class="arithmatex">\(l\)</span> 与 <span class="arithmatex">\(x\)</span> 轴的交点横坐标记为 <span class="arithmatex">\(x_{i+1}\)</span> 。并重复这个迭代的过程。</p>
<p>上述过程可以表示为以下递推式：</p>
<div class="arithmatex">\[
 x_{i+1} = x_i - \frac{f(x_i)}{f^\prime(x_i)}
\]</div>
<p>直观地说，如果 <span class="arithmatex">\(f(x)\)</span> 比较平滑，那么随着迭代次数的增加， <span class="arithmatex">\(x_i\)</span> 会越来越逼近方程的解。</p>
<p>牛顿迭代法的收敛率是平方级别的，这意味着每次迭代后近似解的精确数位会翻倍。</p>
<h2 id="_2">求解平方根</h2>
<p>我们尝试用牛顿迭代法求解平方根。设 <span class="arithmatex">\(f(x)=x^2-n\)</span> ，这个方程的近似解就是 <span class="arithmatex">\(\sqrt{n}\)</span> 的近似解。于是我们得到</p>
<div class="arithmatex">\[
x_{i+1}=x_i-\frac{x_i^2-n}{2x_i}=\frac{x_i+\frac{n}{x_i}}{2}
\]</div>
<p>在实现的时候注意设置合适的精度。代码如下</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">double</span> <span class="nf">sqrt_newton</span><span class="p">(</span><span class="kt">double</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">eps</span> <span class="o">=</span> <span class="mf">1E-15</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">nx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">nx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="_3">求解整数平方根</h2>
<p>尽管我们可以调用 <code>sqrt()</code> 函数来获取平方根的值，但我们还是讲一下牛顿迭代法的变种算法，用于求解 <span class="arithmatex">\(x^2\le n\)</span> 的 <span class="arithmatex">\(x\)</span> 的最大整数解。我们仍然考虑一个类似于牛顿迭代的过程，但需要在边界条件上稍作修改。如果 <span class="arithmatex">\(x\)</span> 在迭代的过程中上一次迭代值得近似解变小，而这一次迭代使得近似解变大，那么我们就不进行这次迭代，退出循环。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="nf">isqrt_newton</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">decreased</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">nx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">n</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">nx</span> <span class="o">||</span> <span class="n">nx</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">decreased</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">decreased</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">nx</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="_4">高精度平方根</h2>
<p>最后考虑高精度的牛顿迭代法。迭代的方法是不变的，但这次我们需要关注初始时近似解的设置，即 <span class="arithmatex">\(x_0\)</span> 的值。由于需要应用高精度的数一般都非常大，因此不同的初始值对于算法效率的影响也很大。一个自然的想法就是考虑 <span class="arithmatex">\(x_0=2^{\left\lfloor\frac{1}{2}\log_2n\right\rfloor}\)</span> ，这样既可以快速计算出 <span class="arithmatex">\(x_0\)</span> ，又可以较为接近平方根的近似解。</p>
<p>给出 Java 代码的实现：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="n">BigInteger</span> <span class="nf">isqrtNewton</span><span class="o">(</span><span class="n">BigInteger</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">BigInteger</span> <span class="n">a</span> <span class="o">=</span> <span class="n">BigInteger</span><span class="o">.</span><span class="na">ONE</span><span class="o">.</span><span class="na">shiftLeft</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">bitLength</span><span class="o">()</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
    <span class="kt">boolean</span> <span class="n">p_dec</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
        <span class="n">BigInteger</span> <span class="n">b</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">divide</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="na">shiftRight</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p_dec</span><span class="o">)</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="n">p_dec</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">b</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>
</td></tr></table>

<p>实践效果：在 <span class="arithmatex">\(n=10^{1000}\)</span> 的时候该算法的运行时间是 60 ms，如果我们不优化 <span class="arithmatex">\(x_0\)</span> 的值，直接从 <span class="arithmatex">\(x_0=1\)</span> 开始算，那么运行时间将达到 120 ms。</p>
<h2 id="_5">习题</h2>
<ul>
<li>
<p><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=16&amp;page=show_problem&amp;problem=1369">UVa 10428 - The Roots</a> </p>
<p><strong>本页面主要译自博文 <a href="http://e-maxx.ru/algo/roots_newton">Метод Ньютона (касательных) для поиска корней</a> 与其英文翻译版 <a href="https://cp-algorithms.com/num_methods/roots_newton.html">Newton's method for finding roots</a> 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。</strong> </p>
</li>
</ul>

</article>


</main>

<div class="footer">
<footer>
<p>&copy; 2016-2019 OI Wiki Team</p>

<p>本页面的全部内容在 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a> 协议之条款下提供，附加条款亦可能应用
</p>



<h5>本页面贡献者</h5>
<ul>
<li>TrisolarisHD</li>

<li>sshwy</li>

</ul>


</footer>
</div>

</body>
</html>
