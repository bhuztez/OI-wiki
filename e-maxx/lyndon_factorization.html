
<!doctype html>
<html>
<head>
<title>
Lyndon factorization
 -
OI Wiki</title>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="/OI-wiki/static/base.css">

</head>
<body>

<header>
<nav>
<a href="/OI-wiki/"><i class="material-icons">school</i> OI Wiki</a>
</nav>
</header>

<main>

<article>
<h1>Lyndon factorization

<a href="https://github.com/OI-wiki/OI-wiki/blob/master/wiki/e-maxx/lyndon_factorization.md"><i class="material-icons">edit</i></a>
<a href="https://github.com/OI-wiki/OI-wiki/commits/master/wiki/e-maxx/lyndon_factorization.md"><i class="material-icons">history</i></a></h1>


<aside class="right">




<h4>标签</h4>

<a class="tag" href="/OI-wiki/tagged/e-maxx.html">E-Maxx</a>

</aside>


<aside class="left">
<h2>目录</h2>
<ul>
<li><a href="#lyndon">Lyndon 分解</a></li>
<li><a href="#duval">Duval 算法</a></li>
<li><a href="#finding-the-smallest-cyclic-shift">最小表示法（Finding the smallest cyclic shift）</a></li>
<li><a href="#_3">习题</a></li>
</ul>
</aside>


<h2 id="lyndon">Lyndon 分解</h2>
<p>首先我们介绍 Lyndon 分解的概念。</p>
<p>Lyndon 串：对于字符串 <span class="arithmatex">\(s\)</span> ，如果 <span class="arithmatex">\(s\)</span> 的字典序严格小于 <span class="arithmatex">\(s\)</span> 的所有后缀的字典序，我们称 <span class="arithmatex">\(s\)</span> 是简单串，或者 <strong>Lyndon 串</strong> 。举一些例子， <span class="arithmatex">\(a\)</span> , <span class="arithmatex">\(b\)</span> , <span class="arithmatex">\(ab\)</span> , <span class="arithmatex">\(aab\)</span> , <span class="arithmatex">\(abb\)</span> , <span class="arithmatex">\(ababb\)</span> , <span class="arithmatex">\(abcd\)</span> 都是 Lyndon 串。如果 <span class="arithmatex">\(s\)</span> 是 Lyndon 串，当且仅当 <span class="arithmatex">\(s\)</span> 的字典序严格小于它的所有非平凡的循环同构串。</p>
<p>Lyndon 分解：串 <span class="arithmatex">\(s\)</span> 的 Lyndon 分解记为 <span class="arithmatex">\(s=w_1w_2\cdots w_k\)</span> ，并且他们的字典序按照非严格单减排序，即 <span class="arithmatex">\(w_1\ge w_2\ge\cdots\ge w_k\)</span> 。可以发现，这样的分解存在且唯一。</p>
<h2 id="duval">Duval 算法</h2>
<p>Duval 可以在 <span class="arithmatex">\(O(n)\)</span> 的时间内求出一个串的 Lyndon 分解。</p>
<p>首先我们介绍另外一个概念：如果一个字符串 <span class="arithmatex">\(t\)</span> 能够分解为 <span class="arithmatex">\(t=ww\cdots\overline{w}\)</span> 的形式，其中 <span class="arithmatex">\(w\)</span> 是一个 Lyndon 串，而 <span class="arithmatex">\(\overline{w}\)</span> 是 <span class="arithmatex">\(w\)</span> 的前缀（ <span class="arithmatex">\(\overline{w}\)</span> 可能是空串），那么称 <span class="arithmatex">\(t\)</span> 是近似简单串（pre-simple），或者近似 Lyndon 串。一个 Lyndon 串也是近似 Lyndon 串。</p>
<p>Duval 算法运用了贪心的思想。算法过程中我们把串 <span class="arithmatex">\(s\)</span> 分成三个部分 <span class="arithmatex">\(s=s_1s_2s_3\)</span> ，其中 <span class="arithmatex">\(s_1\)</span> 是一个 Lyndon 串，它的 Lyndon 分解已经记录； <span class="arithmatex">\(s_2\)</span> 是一个近似 Lyndon 串； <span class="arithmatex">\(s_3\)</span> 是未处理的部分。</p>
<p>整体描述一下，该算法每一次尝试将 <span class="arithmatex">\(s_3\)</span> 的首字符添加到 <span class="arithmatex">\(s_2\)</span> 的末尾。如果 <span class="arithmatex">\(s_2\)</span> 不再是近似 Lyndon 串，那么我们就可以将 <span class="arithmatex">\(s_2\)</span> 截出一部分前缀（即 Lyndon 分解）接在 <span class="arithmatex">\(s_1\)</span> 末尾。</p>
<p>我们来更详细地解释一下算法的过程。定义一个指针 <span class="arithmatex">\(i\)</span> 指向 <span class="arithmatex">\(s_2\)</span> 的末尾字符，则 <span class="arithmatex">\(i\)</span> 从 <span class="arithmatex">\(1\)</span> 遍历到 <span class="arithmatex">\(n\)</span> （字符串长度）。在循环的过程中我们定义另一个指针 <span class="arithmatex">\(j\)</span> 指向 <span class="arithmatex">\(s_3\)</span> 的首字符，指针 <span class="arithmatex">\(k\)</span> 指向我们当前考虑的字符。我们的目标是将 <span class="arithmatex">\(s[j]\)</span> 添加到 <span class="arithmatex">\(s_2\)</span> 的末尾，这就需要将 <span class="arithmatex">\(s[j]\)</span> 与 <span class="arithmatex">\(s[k]\)</span> 做比较：</p>
<ol>
<li>如果 <span class="arithmatex">\(s[j]=s[k]\)</span> ，则将 <span class="arithmatex">\(s[j]\)</span> 添加到 <span class="arithmatex">\(s_2\)</span> 末尾不会影响它的近似简单性。于是我们只需要让指针 <span class="arithmatex">\(j,k\)</span> 自増（移向下一位）即可。</li>
<li>如果 <span class="arithmatex">\(s[j]&gt;s[k]\)</span> ，那么 <span class="arithmatex">\(s_2s[j]\)</span> 就变成了一个 Lyndon 串，于是我们将指针 <span class="arithmatex">\(j\)</span> 自増，而让 <span class="arithmatex">\(k\)</span> 指向 <span class="arithmatex">\(s_2\)</span> 的首字符，这样下一个字符就会继续与 <span class="arithmatex">\(s_2\)</span> 的前缀做比较。</li>
<li>如果 <span class="arithmatex">\(s[j]&lt;s[k]\)</span> ，则 <span class="arithmatex">\(s_2s[j]\)</span> 就不是一个近似简单串了，那么我们就要把 <span class="arithmatex">\(s_2\)</span> 分解出它的一个 Lyndon 子串，这个 Lyndon 子串的长度将是 <span class="arithmatex">\(j-k\)</span> ，然后把 <span class="arithmatex">\(s_2\)</span> 变成分解完以后剩下的部分，继续循环下去（注意，这个情况下我们没有改变指针 <span class="arithmatex">\(j,k\)</span> ）。</li>
</ol>
<h3 id="_1">代码实现</h3>
<p>下面的代码返回串 <span class="arithmatex">\(s\)</span> 的 Lyndon 分解方案。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// duval_algorithm</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">duval</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">factorization</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">else</span>
        <span class="n">k</span><span class="o">++</span><span class="p">;</span>
      <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">factorization</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">k</span><span class="p">));</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">factorization</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_2">复杂度分析</h3>
<p>接下来我们估计一下这个算法的复杂度。</p>
<p>外层的循环次数不超过 <span class="arithmatex">\(n\)</span> ，因为每一次 <span class="arithmatex">\(i\)</span> 都会增加。第二个内层循环也是 <span class="arithmatex">\(O(n)\)</span> 的，因为它只记录 Lyndon 分解的方案。接下来我们分析一下内层循环。很容易发现，每一次在外层循环中找到的 Lyndon 串是比我们所比较过的剩余的串要长的，因此剩余的串的长度和要小于 <span class="arithmatex">\(n\)</span> ，于是我们最多在内层循环 <span class="arithmatex">\(O(n)\)</span> 次。事实上循环的总次数不超过 <span class="arithmatex">\(4n-3\)</span> 。</p>
<h2 id="finding-the-smallest-cyclic-shift">最小表示法（Finding the smallest cyclic shift）</h2>
<p>对于长度为 <span class="arithmatex">\(n\)</span> 的串 <span class="arithmatex">\(s\)</span> ，我们可以通过上述算法寻找该串的最小表示法。</p>
<p>我们构建串 <span class="arithmatex">\(ss\)</span> 的 Lyndon 分解，然后寻找这个分解中的一个 Lyndon 串 <span class="arithmatex">\(t\)</span> ，使得它的起点小于 <span class="arithmatex">\(n\)</span> 且终点大于等于 <span class="arithmatex">\(n\)</span> 。可以证明，子串 <span class="arithmatex">\(t\)</span> 的首字符就是 <span class="arithmatex">\(s\)</span> 的最小表示法的首字符。即我们沿着 <span class="arithmatex">\(t\)</span> 的开头往后 <span class="arithmatex">\(n\)</span> 个字符组成的串就是 <span class="arithmatex">\(s\)</span> 的最小表示法。可以很容易地使用 Lyndon 分解的定义来证明。</p>
<p>于是我们在分解的过程中记录每一次的近似 Lyndon 串的开头即可。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// smallest_cyclic_string</span>
<span class="n">string</span> <span class="nf">min_cyclic_string</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">s</span> <span class="o">+=</span> <span class="n">s</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ans</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="k">else</span>
        <span class="n">k</span><span class="o">++</span><span class="p">;</span>
      <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">)</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">k</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h2 id="_3">习题</h2>
<ul>
<li>
<p><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=660">UVA #719 - Glass Beads</a> </p>
<p><strong>本页面主要译自博文 <a href="http://e-maxx.ru/algo/duval_algorithm">Декомпозиция Линдона. Алгоритм Дюваля. Нахождение наименьшего циклического сдвига</a> 与其英文翻译版 <a href="https://cp-algorithms.com/string/lyndon_factorization.html">Lyndon factorization</a> 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。</strong> </p>
</li>
</ul>

</article>


</main>

<div class="footer">
<footer>
<p>&copy; 2016-2019 OI Wiki Team</p>

<p>本页面的全部内容在 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a> 协议之条款下提供，附加条款亦可能应用
</p>



<h5>本页面贡献者</h5>
<ul>
<li>sshwy</li>

<li>StudyingFather</li>

</ul>


</footer>
</div>

</body>
</html>
