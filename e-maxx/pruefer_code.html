
<!doctype html>
<html>
<head>
<title>
e-maxx/pruefer_code
 -
OI Wiki</title>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="/OI-wiki/static/base.css">

</head>
<body>

<header>
<nav>
<a href="/OI-wiki/"><i class="material-icons">school</i> OI Wiki</a>
</nav>
</header>

<main>

<article>
<h1>e-maxx/pruefer_code

<a href="https://github.com/OI-wiki/OI-wiki/blob/master/wiki/e-maxx/pruefer_code.md"><i class="material-icons">edit</i></a>
<a href="https://github.com/OI-wiki/OI-wiki/commits/master/wiki/e-maxx/pruefer_code.md"><i class="material-icons">history</i></a></h1>


<aside class="right">




<h4>标签</h4>

<a class="tag" href="/OI-wiki/tagged/e-maxx.html">E-Maxx</a>

</aside>


<aside class="left">
<h2>目录</h2>
<ul>
<li><a href="#prufer">Prufer 序列</a></li>
<li><a href="#cayley">Cayley 定理</a></li>
<li><a href="#_3">图连通方案数</a></li>
<li><a href="#_4">习题</a></li>
</ul>
</aside>


<p>本文翻译自 <a href="https://github.com/e-maxx-eng/e-maxx-eng/blob/master/src/graph/pruefer_code.md">e-maxx Prufer Code</a> 。另外解释一下，原文的结点是从 <span class="arithmatex">\(0\)</span> 开始标号的，本文我按照大多数人的习惯改成了从 <span class="arithmatex">\(1\)</span> 标号。</p>
<p>这篇文章介绍 Prufer 序列 (Prufer code)，这是一种将带标号的树用一个唯一的整数序列表示的方法。</p>
<p>使用 Prufer 序列可以证明凯莱定理 (Cayley's formula)。并且我们也会讲解如何计算在一个图中加边使图连通的方案数。</p>
<p><strong>注意</strong> ：我们不考虑含有 <span class="arithmatex">\(1\)</span> 个结点的树。</p>
<h2 id="prufer">Prufer 序列</h2>
<p>Prufer 序列可以将一个带标号 <span class="arithmatex">\(n\)</span> 个结点的树用 <span class="arithmatex">\([1,n]\)</span> 中的 <span class="arithmatex">\(n-2\)</span> 个整数表示。你也可以把它理解为完全图的生成树与数列之间的双射。</p>
<p>显然你不会想不开拿这玩意儿去维护树结构。这玩意儿常用组合计数问题上。</p>
<p>Heinz Prufer 于 1918 年发明这个序列来证明凯莱定理。</p>
<h3 id="prufer_1">对树建立 Prufer 序列</h3>
<p>Prufer 是这样建立的：每次选择一个编号最小的叶结点并删掉它，然后在序列中记录下它连接到的那个结点。重复 <span class="arithmatex">\(n-2\)</span> 次后就只剩下两个结点，算法结束。</p>
<p>显然使用堆可以做到 <span class="arithmatex">\(O(n\log n)\)</span> 的复杂度</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 代码摘自原文，结点是从 0 标号的</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">;</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pruefer_code</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">adj</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">leafs</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">killed</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">leafs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">code</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">leaf</span> <span class="o">=</span> <span class="o">*</span><span class="n">leafs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">leafs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">leafs</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">killed</span><span class="p">[</span><span class="n">leaf</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">u</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">leaf</span><span class="p">])</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">killed</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="n">v</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
    <span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">leafs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">code</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>给一个例子吧，这是一棵 7 个结点的树的 Prufer 序列构建过程：</p>
<p><img alt="prufer" src="./images/prufer1.png"></p>
<p>最终的序列就是 <span class="arithmatex">\(2,2,3,3,2\)</span> 。</p>
<p>当然，也有一个线性的构造算法。</p>
<h3 id="_1">线性构造</h3>
<p>线性构造的本质就是维护一个指针指向我们将要删除的结点。首先发现，叶结点数是非严格单调递减的。要么删一个，要么删一个得一个。（翻译到这突然就知道该怎么做了，然后对照原文发现没什么问题，于是自己口糊吧）</p>
<p>于是我们考虑这样一个过程：维护一个指针 <span class="arithmatex">\(p\)</span> 。初始时 <span class="arithmatex">\(p\)</span> 指向编号最小的叶结点。同时我们维护每个结点的度数，方便我们知道在删除结点的时侯是否产生新的叶结点。操作如下：</p>
<ol>
<li>删除 <span class="arithmatex">\(p\)</span> 指向的结点，并检查是否产生新的叶结点。</li>
<li>如果产生新的叶结点，假设编号为 <span class="arithmatex">\(x\)</span> ，我们比较 <span class="arithmatex">\(p,x\)</span> 的大小关系。如果 <span class="arithmatex">\(x&gt;q\)</span> ，那么不做其他操作；否则就立刻删除 <span class="arithmatex">\(x\)</span> ，然后检查删除 <span class="arithmatex">\(x\)</span> 后是否产生新的叶结点，重复 <span class="arithmatex">\(2\)</span> 步骤，直到未产生新节点或者新节点的编号 <span class="arithmatex">\(&gt;p\)</span> 。</li>
<li>让指针 <span class="arithmatex">\(p\)</span> 自增直到遇到一个未被删除叶结点为止；</li>
</ol>
<p>循环上述操作 <span class="arithmatex">\(n-2\)</span> 次，就完成了序列的构造。接下来考虑算法的正确性。</p>
<p><span class="arithmatex">\(p\)</span> 是当前编号最小的叶结点，若删除 <span class="arithmatex">\(p\)</span> 后未产生叶结点，我们就只能去寻找下一个叶结点；若产生了叶结点 <span class="arithmatex">\(x\)</span> ：</p>
<ul>
<li>如果 <span class="arithmatex">\(x&gt;p\)</span> ，则反正 <span class="arithmatex">\(p\)</span> 往后扫描都会扫到它，于是不做操作；</li>
<li>如果 <span class="arithmatex">\(x&lt;p\)</span> ，因为 <span class="arithmatex">\(p\)</span> 原本就是编号最小的，而 <span class="arithmatex">\(x\)</span> 比 <span class="arithmatex">\(p\)</span> 还小，所以 <span class="arithmatex">\(x\)</span> 就是当前编号最小的叶结点，优先删除。删除 <span class="arithmatex">\(x\)</span> 继续这样的考虑直到没有更小的叶结点。</li>
</ul>
<p>算法复杂度分析，发现每条边最多被访问一次（在删度数的时侯），而指针最多遍历每个结点一次，因此复杂度是 <span class="arithmatex">\(O(n)\)</span> 的。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 从原文摘的代码，同样以 0 为起点</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">adj</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">u</span> <span class="p">:</span> <span class="n">adj</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">,</span> <span class="n">dfs</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pruefer_code</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">adj</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">parent</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">parent</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">dfs</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">code</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">leaf</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">leaf</span><span class="p">];</span>
    <span class="n">code</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">degree</span><span class="p">[</span><span class="n">next</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">next</span> <span class="o">&lt;</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">leaf</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">ptr</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
      <span class="n">leaf</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">code</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="prufer_2">Prufer 序列的性质</h3>
<ol>
<li>在构造完 Prufer 序列后原树中会剩下两个结点，其中一个一定是编号最大的点 <span class="arithmatex">\(n\)</span> 。</li>
<li>每个结点在序列中出现的次数是其度数减 <span class="arithmatex">\(1\)</span> 。（没有出现的就是叶结点）</li>
</ol>
<h3 id="prufer_3">用 Prufer 序列重建树</h3>
<p>重建树的方法是类似的。根据 Prufer 序列的性质，我们可以得到原树上每个点的度数。然后你也可以得到度数最小的叶结点编号，而这个结点一定与 Prufer 序列的第一个数连接。然后我们同时删掉这两个结点的度数。</p>
<p>讲到这里也许你已经知道该怎么做了。每次我们选择一个度数为 <span class="arithmatex">\(1\)</span> 的最小的结点编号，与当前枚举到的 Prufer 序列的点连接，然后同时减掉两个点的度。到最后我们剩下两个度数为 <span class="arithmatex">\(1\)</span> 的点，其中一个是结点 <span class="arithmatex">\(n\)</span> 。就把它们建立连接。使用堆维护这个过程，在减度数的过程中如果发现度数减到 <span class="arithmatex">\(1\)</span> 就把这个结点添加到堆中，这样做的复杂度是 <span class="arithmatex">\(O(n\log n)\)</span> 的。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 原文摘代码</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pruefer_decode</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">code</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">code</span><span class="p">)</span> <span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

  <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">leaves</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">leaves</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">edges</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">leaf</span> <span class="o">=</span> <span class="o">*</span><span class="n">leaves</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">leaves</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">leaves</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>

    <span class="n">edges</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="n">leaves</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">edges</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="o">*</span><span class="n">leaves</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">edges</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<h3 id="_2">线性时间重建树</h3>
<p>同线性构造 Prufer 序列的方法。在删度数的时侯会产生新的叶结点，于是判断这个叶结点与指针 <span class="arithmatex">\(p\)</span> 的大小关系，如果更小就优先考虑它（原文讲得也很略所以我也不细讲啦）</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="c1">// 原文摘代码</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pruefer_decode</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">code</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">degree</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">i</span> <span class="p">:</span> <span class="n">code</span><span class="p">)</span> <span class="n">degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">ptr</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">leaf</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">edges</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nl">v</span> <span class="p">:</span> <span class="n">code</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">edges</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">leaf</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">degree</span><span class="p">[</span><span class="n">ptr</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">ptr</span><span class="o">++</span><span class="p">;</span>
      <span class="n">leaf</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">edges</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">edges</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>通过这些过程其实可以理解，Prufer 序列与带标号无根树建立了双射关系。</p>
<h2 id="cayley">Cayley 定理</h2>
<p>凯莱定理描述如下：所有群 <span class="arithmatex">\(G\)</span> 同构于在 <span class="arithmatex">\(G\)</span> 上的对称群的子群。</p>
<p>是不是一脸懵逼不知所措</p>
<p>还有另一种表述：完全图 <span class="arithmatex">\(K_n\)</span> 有 <span class="arithmatex">\(n^{n-2}\)</span> 棵生成树。</p>
<p>怎么证明？方法很多，但是用 Prufer 序列证是很简单的。任意一个长度为 <span class="arithmatex">\(n-2\)</span> 的值域 <span class="arithmatex">\([1,n]\)</span> 的整数序列都可以通过 Prufer 序列双射对应一个生成树，于是方案数就是 <span class="arithmatex">\(n^{n-2}\)</span> 。</p>
<h2 id="_3">图连通方案数</h2>
<p>Prufer 序列可能比你想得还强大。它能创造比凯莱定理更通用的公式。比如以下问题：</p>
<blockquote>
<p>一个 <span class="arithmatex">\(n\)</span> 个点 <span class="arithmatex">\(m\)</span> 条边的带标号无向图有 <span class="arithmatex">\(k\)</span> 个连通块。我们希望添加 <span class="arithmatex">\(k-1\)</span> 条边使得整个图连通。求方案数。</p>
</blockquote>
<p>设 <span class="arithmatex">\(s_i\)</span> 表示每个连通块的数量。我们对 <span class="arithmatex">\(k\)</span> 个连通块构造 Prufer 序列，然后你发现这并不是普通的 Prufer 序列。因为每个连通块的连接方法很多。不能直接淦就设啊。于是设 <span class="arithmatex">\(d_i\)</span> 为第 <span class="arithmatex">\(i\)</span> 个连通块的度数。由于度数之和是边数的两倍，于是 <span class="arithmatex">\(\sum_{i=1}^kd_i=2k-2\)</span> 。则对于给定的 <span class="arithmatex">\(d\)</span> 序列构造 Prufer 序列的方案数是</p>
<div class="arithmatex">\[
\binom{k-2}{d_1-1,d_2-1,\cdots,d_k-1}=\frac{(k-2)!}{(d_1-1)!(d_2-1)!\cdots(d_k-1)!}
\]</div>
<p>对于第 <span class="arithmatex">\(i\)</span> 个连通块，它的连接方式有 <span class="arithmatex">\({s_i}^{d_i}\)</span> 种，因此对于给定 <span class="arithmatex">\(d\)</span> 序列使图连通的方案数是</p>
<div class="arithmatex">\[
\binom{k-2}{d_1-1,d_2-1,\cdots,d_k-1}\cdot \prod_{i=1}^k{s_i}^{d_i}
\]</div>
<p>现在我们要枚举 <span class="arithmatex">\(d\)</span> 序列，式子变成</p>
<div class="arithmatex">\[
\sum_{d_i\ge 1，\sum_{i=1}^kd_i=2k-2}\binom{k-2}{d_1-1,d_2-1,\cdots,d_k-1}\cdot \prod_{i=1}^k{s_i}^{d_i}
\]</div>
<p>好的这是一个非常不喜闻乐见的式子。但是别慌！我们有多元二项式定理：</p>
<div class="arithmatex">\[
(x_1 + \dots + x_m)^p = \sum_{\substack{c_i \ge 0 ,\  \sum_{i=1}^m c_i = p}} \binom{p}{c_1, c_2, \cdots ,c_m}\cdot \prod_{i=1}^m{x_i}^{c_i}
\]</div>
<p>那么我们对原式做一下换元，设 <span class="arithmatex">\(e_i=d_i-1\)</span> ，显然 <span class="arithmatex">\(\sum_{i=1}^ke_i=k-2\)</span> ，于是原式变成</p>
<div class="arithmatex">\[
\sum_{e_i\ge 0，\sum_{i=1}^ke_i=k-2}\binom{k-2}{e_1,e_2,\cdots,e_k}\cdot \prod_{i=1}^k{s_i}^{e_i+1}
\]</div>
<p>化简得到</p>
<div class="arithmatex">\[
(s_1+s_2+\cdots+s_k)^{k-2}\cdot \prod_{i=1}^ks_i
\]</div>
<p>即</p>
<div class="arithmatex">\[
n^{k-2}\cdot\prod_{i=1}^ks_i
\]</div>
<p>这就是答案啦</p>
<h2 id="_4">习题</h2>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=20&amp;page=show_problem&amp;problem=1784">UVA #10843 - Anne's game</a> </li>
<li><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1069">Timus #1069 - Prufer Code</a> </li>
<li><a href="http://codeforces.com/contest/156/problem/D">Codeforces - Clues</a> </li>
<li><a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=10774&amp;rd=14146">Topcoder - TheCitiesAndRoadsDivTwo</a> </li>
</ul>

</article>


</main>

<div class="footer">
<footer>
<p>&copy; 2016-2019 OI Wiki Team</p>

<p>本页面的全部内容在 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a> 协议之条款下提供，附加条款亦可能应用
</p>





</footer>
</div>

</body>
</html>
