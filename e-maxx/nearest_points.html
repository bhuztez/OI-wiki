
<!doctype html>
<html>
<head>
<title>
Finding the nearest pair of points
 -
OI Wiki</title>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="/OI-wiki/static/base.css">

</head>
<body>

<header>
<nav>
<a href="/OI-wiki/"><i class="material-icons">school</i> OI Wiki</a>
</nav>
</header>

<main>

<article>
<h1>Finding the nearest pair of points

<a href="https://github.com/OI-wiki/OI-wiki/blob/master/wiki/e-maxx/nearest_points.md"><i class="material-icons">edit</i></a>
<a href="https://github.com/OI-wiki/OI-wiki/commits/master/wiki/e-maxx/nearest_points.md"><i class="material-icons">history</i></a></h1>


<aside class="right">




<h4>标签</h4>

<a class="tag" href="/OI-wiki/tagged/e-maxx.html">E-Maxx</a>

</aside>


<aside class="left">
<h2>目录</h2>
<ul>
<li><a href="#_1">概述</a></li>
<li><a href="#_2">算法</a></li>
<li><a href="#_3">复杂度证明</a></li>
<li><a href="#_4">实现</a></li>
<li><a href="#_5">推广：平面最小周长三角形</a></li>
<li><a href="#_6">习题</a></li>
</ul>
</aside>


<h2 id="_1">概述</h2>
<p>给定 <span class="arithmatex">\(n\)</span> 个二维平面上的点，求一组欧几里得距离最近的点对。</p>
<p>下面我们介绍一种时间复杂度为 <span class="arithmatex">\(O(n\log n)\)</span> 的分治算法来解决这个问题。该算法在 1975 年由 <a href="https://en.wikipedia.org/wiki/Franco_P._Preparata">Franco P. Preparata</a> 提出，Preparata 和 <a href="https://en.wikipedia.org/wiki/Michael_Ian_Shamos">Michael Ian Shamos</a> 证明了该算法在决策树模型下是最优的。</p>
<h2 id="_2">算法</h2>
<p>与常规的分治算法一样，我们将这个有 <span class="arithmatex">\(n\)</span> 个点的集合拆分成两个大小相同的集合 <span class="arithmatex">\(S_1, S_2\)</span> ，并不断递归下去。但是我们遇到了一个难题：如何合并？即如何求出一个点在 <span class="arithmatex">\(S_1\)</span> 中，另一个点在 <span class="arithmatex">\(S_2\)</span> 中的最近点对？这里我们先假设合并操作的时间复杂度为 <span class="arithmatex">\(O(n)\)</span> ，可知算法总复杂度为 <span class="arithmatex">\(T(n) = 2T(\frac{n}{2}) + O(n) = O(n\log n)\)</span> 。</p>
<p>我们先将所有点按照 <span class="arithmatex">\(x_i\)</span> 为第一关键字、 <span class="arithmatex">\(y_i\)</span> 为第二关键字排序，并以点 <span class="arithmatex">\(p_m (m = \lfloor \frac{n}{2} \rfloor)\)</span> 为分界点，拆分点集为 <span class="arithmatex">\(A_1,A_2\)</span> ：</p>
<div class="arithmatex">\[
A_1 = \{p_i \ \big | \ i = 0 \ldots m \}\\
A_2 = \{p_i \ \big | \ i = m + 1 \ldots n-1 \}
\]</div>
<p>并递归下去，求出两点集各自内部的最近点对，设距离为 <span class="arithmatex">\(h_1,h_2\)</span> ，取较小值设为 <span class="arithmatex">\(h\)</span> 。</p>
<p>现在该合并了！我们试图找到这样的一组点对，其中一个属于 <span class="arithmatex">\(A_1\)</span> ，另一个属于 <span class="arithmatex">\(A_2\)</span> ，且二者距离小于 <span class="arithmatex">\(h\)</span> 。因此我们将所有横坐标与 <span class="arithmatex">\(x_m\)</span> 的差小于 <span class="arithmatex">\(h\)</span> 的点放入集合 <span class="arithmatex">\(B\)</span> ：</p>
<div class="arithmatex">\[
B = \{ p_i \ \big | \ \lvert x_i - x_m \rvert &lt; h \}
\]</div>
<p>对于 <span class="arithmatex">\(B\)</span> 中的每个点 <span class="arithmatex">\(p_i\)</span> ，我们当前目标是找到一个同样在 <span class="arithmatex">\(B\)</span> 中、且到其距离小于 <span class="arithmatex">\(h\)</span> 的点。为了避免两个点之间互相考虑，我们只考虑那些纵坐标小于 <span class="arithmatex">\(y_i\)</span> 的点。显然对于一个合法的点 <span class="arithmatex">\(p_j\)</span> ， <span class="arithmatex">\(y_i - y_j\)</span> 必须小于 <span class="arithmatex">\(h\)</span> 。于是我们获得了一个集合 <span class="arithmatex">\(C(p_i)\)</span> ：</p>
<div class="arithmatex">\[
C(p_i) = \{ p_j\ \big |\ p_j \in B,\ y_i - h &lt; y_j \le y_i \}
\]</div>
<p>如果我们将 <span class="arithmatex">\(B\)</span> 中的点按照 <span class="arithmatex">\(y_i\)</span> 排序， <span class="arithmatex">\(C(p_i)\)</span> 将很容易得到，即紧邻 <span class="arithmatex">\(p_i\)</span> 的连续几个点。</p>
<p>由此我们得到了合并的步骤：</p>
<ol>
<li>构建集合 <span class="arithmatex">\(B\)</span> 。</li>
<li>将 <span class="arithmatex">\(B\)</span> 中的点按照 <span class="arithmatex">\(y_i\)</span> 排序。通常做法是 <span class="arithmatex">\(O(n\log n)\)</span> ，但是我们可以改变策略优化到 <span class="arithmatex">\(O(n)\)</span> （下文讲解）。</li>
<li>对于每个 <span class="arithmatex">\(p_i \in B\)</span> 考虑 <span class="arithmatex">\(p_j \in C(p_i)\)</span> ，对于每对 <span class="arithmatex">\((p_i,p_j)\)</span> 计算距离并更新答案（当前所处集合的最近点对）。</li>
</ol>
<p>注意到我们上文提到了两次排序，因为点坐标全程不变，第一次排序可以只在分治开始前进行一次。我们令每次递归返回当前点集按 <span class="arithmatex">\(y_i\)</span> 排序的结果，对于第二次排序，上层直接使用下层的两个分别排序过的点集归并即可。</p>
<p>似乎这个算法仍然不优， <span class="arithmatex">\(|C(p_i)|\)</span> 将处于 <span class="arithmatex">\(O(n)\)</span> 数量级，导致总复杂度不对。其实不然，其最大大小为 <span class="arithmatex">\(7\)</span> ，我们给出它的证明：</p>
<h2 id="_3">复杂度证明</h2>
<p>我们已经了解到， <span class="arithmatex">\(C(p_i)\)</span> 中的所有点的纵坐标都在 <span class="arithmatex">\((y_i-h,y_i]\)</span> 范围内；且 <span class="arithmatex">\(C(p_i)\)</span> 中的所有点，和 <span class="arithmatex">\(p_i\)</span> 本身，横坐标都在 <span class="arithmatex">\((x_m-h,x_m+h)\)</span> 范围内。这构成了一个 <span class="arithmatex">\(2h \times h\)</span> 的矩形。</p>
<p>我们再将这个矩形拆分为两个 <span class="arithmatex">\(h \times h\)</span> 的正方形，不考虑 <span class="arithmatex">\(p_i\)</span> ，其中一个正方形中的点为 <span class="arithmatex">\(C(p_i) \cap A_1\)</span> ，另一个为 <span class="arithmatex">\(C(p_i) \cap A_2\)</span> ，且两个正方形内的任意两点间距离大于 <span class="arithmatex">\(h\)</span> 。（因为它们来自同一下层递归）</p>
<p>我们将一个 <span class="arithmatex">\(h \times h\)</span> 的正方形拆分为四个 <span class="arithmatex">\(\frac{h}{2} \times \frac{h}{2}\)</span> 的小正方形。可以发现，每个小正方形中最多有 <span class="arithmatex">\(1\)</span> 个点：因为该小正方形中任意两点最大距离是对角线的长度，即 <span class="arithmatex">\(\frac{h}{\sqrt 2}\)</span> ，该数小于 <span class="arithmatex">\(h\)</span> 。</p>
<p>由此，每个正方形中最多有 <span class="arithmatex">\(4\)</span> 个点，矩形中最多有 <span class="arithmatex">\(8\)</span> 个点，去掉 <span class="arithmatex">\(p_i\)</span> 本身， <span class="arithmatex">\(\max(C(p_i))=7\)</span> 。</p>
<h2 id="_4">实现</h2>
<p>我们使用一个结构体来存储点，并定义用于排序的函数对象：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">pt</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cmp_x</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">pt</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">pt</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cmp_y</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">pt</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">pt</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">pt</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</pre></div>
</td></tr></table>

<p>为了方便实现递归，我们引入 <code>upd_ans()</code> 辅助函数来计算两点间距离并尝试更新答案：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">double</span> <span class="n">mindist</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">ansa</span><span class="p">,</span> <span class="n">ansb</span><span class="p">;</span>

<span class="kr">inline</span> <span class="kt">void</span> <span class="nf">upd_ans</span><span class="p">(</span><span class="k">const</span> <span class="n">pt</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">pt</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">dist</span> <span class="o">=</span>
      <span class="n">sqrt</span><span class="p">((</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mf">.0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">mindist</span><span class="p">)</span> <span class="n">mindist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">,</span> <span class="n">ansa</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">id</span><span class="p">,</span> <span class="n">ansb</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>下面是递归本身：假设在调用前 <code>a[]</code> 已按 <span class="arithmatex">\(x_i\)</span> 排序。如果 <span class="arithmatex">\(r-l\)</span> 过小，使用暴力算法计算 <span class="arithmatex">\(h\)</span> ，终止递归。</p>
<p>我们使用 <code>std::merge()</code> 来执行归并排序，并创建辅助缓冲区 <code>t[]</code> ， <span class="arithmatex">\(B\)</span> 存储在其中。</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="kt">void</span> <span class="nf">rec</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="n">upd_ans</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
    <span class="n">sort</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmp_y</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">midx</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">m</span><span class="p">].</span><span class="n">x</span><span class="p">;</span>
  <span class="n">rec</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">rec</span><span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
  <span class="k">static</span> <span class="n">pt</span> <span class="n">t</span><span class="p">[</span><span class="n">MAXN</span><span class="p">];</span>
  <span class="n">merge</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">l</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmp_y</span><span class="p">);</span>
  <span class="n">copy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">l</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">tsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">-</span> <span class="n">midx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mindist</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">tsz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">mindist</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
        <span class="n">upd_ans</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
      <span class="n">t</span><span class="p">[</span><span class="n">tsz</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

<p>在主函数中，这样开始递归即可：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span>1
2
3</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmp_x</span><span class="p">);</span>
<span class="n">mindist</span> <span class="o">=</span> <span class="mf">1E20</span><span class="p">;</span>
<span class="n">rec</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</td></tr></table>

<h2 id="_5">推广：平面最小周长三角形</h2>
<p>上述算法有趣地推广到这个问题：在给定的一组点中，选择三个点，使得它们两两的距离之和最小。</p>
<p>算法大体保持不变，每次尝试找到一个比当前答案周长 <span class="arithmatex">\(d\)</span> 更小的三角形，将所有横坐标与 <span class="arithmatex">\(x_m\)</span> 的差小于 <span class="arithmatex">\(\frac{d}{2}\)</span> 的点放入集合 <span class="arithmatex">\(B\)</span> ，尝试更新答案。（周长为 <span class="arithmatex">\(d\)</span> 的三角形的最长边小于 <span class="arithmatex">\(\frac{d}{2}\)</span> ）</p>
<h2 id="_6">习题</h2>
<ul>
<li><a href="https://uva.onlinejudge.org/index.php?option=onlinejudge&amp;page=show_problem&amp;problem=1186">UVA 10245 "The Closest Pair Problem"[难度：低]</a> </li>
<li><a href="https://www.spoj.com/problems/CLOPPAIR/">SPOJ #8725 CLOPPAIR "Closest Point Pair"[难度：低]</a> </li>
<li><a href="http://codeforces.com/contest/120/problem/J">CODEFORCES Team Olympiad Saratov - 2011 "Minimum amount"[难度：中]</a> </li>
<li><a href="https://code.google.com/codejam/contest/311101/dashboard#s=a&amp;a=1">Google CodeJam 2009 Final "Min Perimeter"[难度：中]</a> </li>
<li><a href="https://www.spoj.com/problems/CLOSEST/">SPOJ #7029 CLOSEST "Closest Triple"[难度：中]</a> </li>
</ul>
<hr>
<p><strong>本页面主要译自博文 <a href="http://e-maxx.ru/algo/nearest_points">Нахождение пары ближайших точек</a> 与其英文翻译版 <a href="https://github.com/e-maxx-eng/e-maxx-eng/blob/master/src/geometry/nearest_points.md">Finding the nearest pair of points</a> 。其中俄文版版权协议为 Public Domain + Leave a Link；英文版版权协议为 CC-BY-SA 4.0。</strong> </p>

</article>


</main>

<div class="footer">
<footer>
<p>&copy; 2016-2019 OI Wiki Team</p>

<p>本页面的全部内容在 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a> 协议之条款下提供，附加条款亦可能应用
</p>





</footer>
</div>

</body>
</html>
