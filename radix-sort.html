
<!doctype html>
<html>
<head>
<title>
基数排序
 -
OI Wiki</title>

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<link rel="stylesheet" href="/OI-wiki/static/base.css">

</head>
<body>

<header>
<nav>
<a href="/OI-wiki/"><i class="material-icons">school</i> OI Wiki</a>
</nav>
</header>

<main>

<article>
<h1>基数排序

<a href="https://github.com/OI-wiki/OI-wiki/blob/master/wiki/radix-sort.md"><i class="material-icons">edit</i></a>
<a href="https://github.com/OI-wiki/OI-wiki/commits/master/wiki/radix-sort.md"><i class="material-icons">history</i></a></h1>


<aside class="right">




<h4>标签</h4>

<a class="tag" href="/OI-wiki/tagged/sort.html">排序</a>

</aside>


<aside class="left">
</aside>


<p>基数排序是将待排序的元素拆分为 <span class="arithmatex">\(k\)</span> 个关键字（比较两个元素时，先比较第一关键字，如果相同再比较第二关键字……），然后先对第 <span class="arithmatex">\(k\)</span> 关键字进行稳定排序，再对第 <span class="arithmatex">\(k-1\)</span> 关键字进行稳定排序，再对第 <span class="arithmatex">\(k-2\)</span> 关键字进行稳定排序……最后对第一关键字进行稳定排序，这样就完成了对整个待排序序列的稳定排序。</p>
<p>基数排序的正确性可以自己感性理解一下，也可以参考 <a href="https://walkccc.github.io/CLRS/Chap08/8.3/#83-3">https://walkccc.github.io/CLRS/Chap08/8.3/#83-3</a> 。</p>
<p>一般来说，每个关键字的值域都不大，就可以使用 <a href="/OI-wiki/counting-sort.html">计数排序</a> 作为内层排序，复杂度为 <span class="arithmatex">\(O(nk+\sum\limits_{i=1}^k w_i)\)</span> ，其中 <span class="arithmatex">\(w_i\)</span> 为第 <span class="arithmatex">\(i\)</span> 关键字的值域大小。</p>
<p>（如果关键字值域很大，就可以直接使用基于比较的 <span class="arithmatex">\(O(nk\log n)\)</span> 排序而无需使用基数排序了。）</p>
<p>伪代码：</p>
<div class="arithmatex">\[
\begin{array}{ll}
1 &amp; \textbf{Input. } \text{An array } A \text{ consisting of }n\text{ elements, where each element has }k\text{ keys.}\\
2 &amp; \textbf{Output. } \text{Array }A\text{ will be sorted in nondecreasing order stably.} \\
3 &amp; \textbf{Method. }  \\
4 &amp; \textbf{for }i\gets k\textbf{ down to }1\\
5 &amp; \qquad\text{sort }A\text{ into nondecreasing order by the }i\text{-th key stably}
\end{array}
\]</div>
<p>C++ 代码：</p>
<table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="codehilite"><pre><span></span><span class="k">const</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">100010</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">W</span> <span class="o">=</span> <span class="mi">100010</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">K</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">w</span><span class="p">[</span><span class="n">K</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">cnt</span><span class="p">[</span><span class="n">W</span><span class="p">];</span>

<span class="k">struct</span> <span class="n">Element</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">K</span><span class="p">];</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span> <span class="n">Element</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="k">const</span>  <span class="c1">// shows how two elements are compared</span>
  <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">.</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">.</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">counting_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cnt</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="o">++</span><span class="n">cnt</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">[</span><span class="n">p</span><span class="p">]];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">w</span><span class="p">[</span><span class="n">p</span><span class="p">];</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">cnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cnt</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">b</span><span class="p">[</span><span class="n">cnt</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="n">memcpy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">radix_sort</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">counting_sort</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>

</article>


</main>

<div class="footer">
<footer>
<p>&copy; 2016-2019 OI Wiki Team</p>

<p>本页面的全部内容在 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC BY-SA 4.0</a> 和 <a href="https://github.com/zTrix/sata-license">SATA</a> 协议之条款下提供，附加条款亦可能应用
</p>





</footer>
</div>

</body>
</html>
